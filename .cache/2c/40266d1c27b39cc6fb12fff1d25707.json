{"id":"GJf3","dependencies":[],"generated":{"js":"module.exports = \"---\\ntitle: Linux Kernel Programming Notes\\nauthor: Aidan Lawford-Wickham\\ndate: '2019-11-20T20:17:34.026Z'\\nslug: kernel_notes\\ntags:\\n - Linux Kernel\\n - C\\n - Make\\n - Device Drivers\\n---\\n\\nThis is a collection of notes covering basic Linux kernel and device driver programming. I made it to help myself remember\\nimportant concepts, and I share it here because it might prove useful to other people as they enter the world of kernel programming.\\n\\n### Module Basics\\n\\n#### Building a module\\n\\nWe'll start with some of the basic building blocks for a kernel module.\\n\\n`<linux/init.h>` and `<linux/module.h>` are included at the top of a module.\\n\\nAlways define the following functions to initialize and exit the module:\\n\\n```clike\\nstatic int <module_name>_init(void) {\\n    ...\\n}\\n```\\n\\nand\\n\\n```clike\\nstatic void <module_name>_exit(void) {\\n    ...\\n}\\n```\\n\\nThen call the functions `module_init(<module_name>_init)` and `module_exit(<module_name>_exit)`\\n\\nIn the Makefile, you can can use `obj-m := <module_name>.o` to define what needs to be built.\\nAdd more modules to build using `obj-m += <module_name_2>.o`\\n\\nYou can build multiple files that form a single module (for which there is no single file) by adding the following to your Makefile:\\n\\n```makefile\\nobj-m := <module_name>.o\\n<module_name>-objs := <file_name_1>.o <file_name_2>.o\\n```\\n\\nRun `make`, then you're ready to insert the module into the kernel:\\n\\n`insmod <module_name>.ko`\\n\\nYou can remove the module using `rmmod <module_name>`, and list modules with `lsmod`\\n\\nOpen a new shell window, and view kernel logs with `tail -f /var/log/kern.log` or `tail -f /var/log/syslog`\\n\\n\\n#### Importing/Exporting from modules\\n\\n- Export function or variable using `EXPORT_SYMBOL(function_name);` after definition\\n\\n- Write prototype when importing like so: `extern void function_name(int);` or `extern int GLOBAL_VARIABLE;`\\n\\n- Must insert the one exporting first, then the one importing. Must build both using make. Must remove the one importing first, then the one exporting.\\n\\n- Can use `modprobe importing_module` to insert in correct order.\\n\\n- Can import string related operations in linux kernel, which are already exported. Seee the list using `cat /proc/kallsyms | grep \\\"T str\\\"`.\\n- use `#include <string.h>` then use the function name inside program.\\n\\n\\n#### Module parameters\\n- Exploit global variable as module parameter (can specify it when the module is inserted) using macro `module_param`\\n\\n- Default value is what is initialized in source code (must be provided)\\n```clike\\n#include <linux/moduleparam.h>\\n\\nint count = 1;\\nmodule_param(count, int, 0) // Pass name, type, and permission\\n```\\n\\nSpecify the parameter when inserting:\\n\\n```bash\\nsudo insmod ./module.ko count=5\\n```\\n\\nPermission arguments:\\n\\n6 - read and write\\n4 - only read access\\n\\ne.g. \\\"0644\\\"\\n- creator 6\\n\\n- other members of group 4\\n\\n- members not in group 4\\n\\nView module parameters with permissions:\\n\\n`ls -l /sys/module/module_name/parameters/count`\\n\\nView value of module parameter:\\n\\n`cat /sys/module/module_name/parameters/count`\\n\\nView value of module parameter count to 5 after setting it:\\n\\n`echo 5 | sudo tee /sys/module/module_name/parameters/count`\\n\\n\\n\\n### Device Drivers\\n\\nDevice drivers are devices on which you can modify the system.\\n\\nTo view all devices in system: `cat /proc/devices`\\n\\n#### Overall Process\\n\\n1. Make device file so user can access physical device in kernel space (allows them to open, write, read, and close device). This means using `mknod` to make a device entry.\\n\\n2. Device file does file operations on driver, which communicates with device.\\n\\n#### Block device drivers\\n\\n- Any device that allows you to go forwards or backwards between files, e.g. skipping a song or playing a song again\\n\\n- Aynchonous, user does not need to wait for reading/writing of device to be completed\\n\\n#### Character device driver\\n\\n- Continuous stream of data, no ability to go back and forth, e.g. keyboard or mouse.\\n\\n- Synchonous, user must wait for reading/writing of device to be completed\\n\\n- Find device drivers with `ls -l /dev | head`\\n  - Major number and minor number included, major number is unique id for a driver associated with the device, minor number is number of instances\\n\\n- Find hard disks `ls /dev | grep sda` (these all use same block device)\\n\\n- Essentially, we write the device driver using a specific major number, then we can register devices to use that driver (write device files specifying this driver).\\n\\n- `/dev` is a filesystem that only exists in RAM\\n- To make a device entry (create device file): `mknod -m 666 /dev/simple_char_device c 240 0`\\n  - `-m 666` everybody gets read and write access\\n\\n  - `c` for character device, then list major and minor numbers\\n\""},"sourceMaps":null,"error":null,"hash":"67b8982c2593c2a874b28e67c340a86e","cacheData":{}}